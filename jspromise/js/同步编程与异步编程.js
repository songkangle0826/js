/*
 * JS中的同步编程和异步编程
 * 	同步编程： 任务是按照顺序依次处理，当前这件事没有彻底昨晚，下一件事是执行不了的
 *  异步编程： 当前这件事没有彻底昨晚，需要等待一段时间才能继续处理，此时我们不等，继续执行下面的任务，当后面的任务完成后，再去把没有彻底完成的事情完成
 *
 * 【js中的异步编程】
 *	1.所有的事件绑定都是异步编程 xxx.onclick = function(){}
 	2.所有定时器都是异步编程 setTimeout(function(){},1000)
 	3.AJAX中一般都使用异步编程处理
 	4.回调函数也是异步编程
 	...
 *
*/ 


/*
	let n = 0;
	setTimeout(()=>{
		console.log(++n)  //1
	},1000)
	console.log(n)	0
*/

/*
	//定时器设定一个时间，到达时间后不一定执行（如果当前还有其他的同步任务正在处理，那么到时间了也得等着）
	let n = 0;
	setTimeout(()=>{
		console.log(++n) //没有输出
	},1000)
	console.log(n)	0
	while(1===1){
		//死循环
	}
*/

// => 浏览器如何规划同步异步机制的
// 1.浏览器是多进程的，js是单线程的（浏览器只会给js执行分配一个线程）：单线程得特点就是一次只能处理一件事情
	// 进程:每一个应用程序都可以理解为一个进程，（浏览器打开一个页面，就相当于开辟一个进程），在一个程序中（进程中）我们经常会干好多事情，此时我们可以分配多个线程去同时完成多项任务

// 2.js在单线程中实现异步得机制，主要依赖于浏览器得任务队列完成得。浏览器中有两个任务队列（主任务队列，等待任务队列）


// js实现异步编程的底层原理

// 1.在主任务自上而下执行得时候，如果遇到一个异步操作任务，没有立即执行，而是把它放到等待任务队列中排队
// 2.当主任务队列完成后才会等待任务队列进行查找（主任务队列完不成，不管等待任务队列中是否有达到时间得，都不处理，继续等待主任务队列完成得，因为js是单线程得【一次只能处理一件事情】）
// 3.等待任务队列谁达到条件了（如果有很多都到达了条件，谁先到达得，就先处理谁），就把这个任务从新放到主任务队列中去执行，把这个任务执行完成后，再去等待中查找.....



/*
	setTimeout(()=>{
		console.log(1)
	},20)
	console.log(2);

	setTimeout(()=>{
		console.log(3)
	},10)

	setTimeout(()=>{
		console.log(4)
	},100)

	// console.time("AA")
	let startTime = new Date();
	for(let i = 0;i<90000000;i++){

	}
	console.log(5)
	// console.timeEnd("AA")
	console.log(new Date() - startTime)
*/


/*
	let n = 0;
	setTimeout(()=>{
		console.log(++n)
	},0) // => 定时器时间因子设置为零不是立即执行，每个浏览器都有一个自己最小的等待和反应时间（谷歌：5-6s IE：10-13），所有写零还是异步编程
	console.log(n)
*/


