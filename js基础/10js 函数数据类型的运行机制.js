// 引用类型的特殊的 函数类型
/*
 * 在js中，函数就是一个方法（一个功能题），基于函数一般都是为了实现某个功能
 * 函数诞生的目的就是为了实现封装：把实现一个功能的代码封装到一个函数中，后期想要实现这个功能，只需要把函数执行即可，不必再次编写重复的代码，起到了”低耦合高内聚（减少页面中的冗余代码，提高代码的重复使用率）“
 * 创建函数 function fn(){ }
 * 执行 fn()
*/ 

/*
ES3标准中:
//=>创建函数
function 函数名([参数]){
	函数体：实现功能的js代码
}
//=>函数执行
函数名();
*/ 

// ===
/*
ES6标准中创建箭头函数
let 函数名(变量名)=([参数])=>{
	函数体
}
函数名();
*/ 

/*
 * 函数的运作机制
 * 函数作为引用数据类型中的一种，它是按照引用地址来操作的。
function fn(){
	var obj = 10;
	total+=10;
	total=total.toFixed(2)
	console.log(total)
}

 * 【创建函数】
 * 1.函数也是引用类型，首先会开辟一个新的堆内存，把函数体中大代码当做”字符串“存储到内存中（对象向内存中存储的是键值对）
 * 2.把开辟的堆内存地址赋值给函数名（变量名）

 * 此时我们输出fn（切记不是fn()）代表函数本身，如果我们执行fn(),这是把函数执行，所有是否加小括号是两种不同本质的操作
 
 * 【函数执行】
 * 目的: 把之前存储到堆内存中的代码字符串变为真正的js代码自上而下执行，从而实现应由的功能
 	*1.函数执行，首先会形成一个私有的作用域（一个供代码执行的环境，也就是一个栈内存）
	*2.把之前的堆内存中存储的字符串复制一份过来，变为真真正的js代码，在新开辟的作用域中自上而下执行；
*/ 


// 函数中的参数 
// 参数是函数的入口：当我们在函数中封装一个功能。发现一些原材料不确定，需要执行函数的时候用户传递进来的才可以，此时我们就基于参数的机制，提供出口即可
function sum(a,b){ //此处的参数叫做形参：入口，形参就是变量
	return a+b
}
//此处的参数叫做实参：实参就是值
sum(10,12)   // =>n=10,m=20
sum(10);     // =>n=10,m=undefined
sum(10,20,30) //=>n=10,m=20,30没有形参变量接受
